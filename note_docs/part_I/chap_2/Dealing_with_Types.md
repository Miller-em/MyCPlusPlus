# 处理对象

随着程序越来越复杂，程序中用到的类型也越来越复杂，这种复杂体现在两个方面。一个一些类型难以拼写，二是有时候根本搞不清楚需要的类型是什么，程序员不得不回过头去从程序上下文需求帮助。

## 类型别名

类型别名是一个名字，他是某种类型的同义词。使用类型别名的好处是让复杂的类型名字变得简单明了。

### typedef

关键字**typedef**，用于定义类型别名不再是变量：

```c++
typedef double wages;	// wages是double的同义词
typedef wages base, *p; //base是double的同义词，p是double*的同义词
```

### 别名说明

新标准规定了一种方法，使用**别名声明**来定义类型的别名：

```c++
using SI = Sales_item //SI是Sales_item 的同义词
```

## auto类型说明符

编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚的知道表达式的类型。然而要做到这一点并未那么容易，有时甚至根本做不到，为了解决这个问题，C++11新标准引入了**auto**类型说明符，用它就能够让编译器替我们去分析表达式所属的类型。

```c++
auto item = val1 + val2; //item初始化为val1和val2相加的结果，右相加的结果可以推断出是item的类型
auto i = 0; *p = &i; //正确， i是整数，p是整形指针
auto sz = 0, pi = 3.14;	//错误：sz和pi的类型不一样
```

## decltype 类型指示符

`decltype`与`auto`关键字一样，用于进行编译时类型推导，不过它与auto还是有一些区别的。`decltype`的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，而是总是**以一个普通表达式作为参数**，返回该表达式的类型,而且`decltype`并不会对表达式进行求值。

```c++
    int i = 4;
    decltype(i) a; //推导结果为int。a的类型为int。
```

